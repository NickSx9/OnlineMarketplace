{"ast":null,"code":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { HeaderNames } from \"./HeaderNames\";\nimport { HttpClient } from \"./HttpClient\";\n/** @private */\n\nexport class AccessTokenHttpClient extends HttpClient {\n  constructor(innerClient, accessTokenFactory) {\n    super();\n    this._innerClient = innerClient;\n    this._accessTokenFactory = accessTokenFactory;\n  }\n\n  async send(request) {\n    let allowRetry = true;\n\n    if (this._accessTokenFactory && (!this._accessToken || request.url && request.url.indexOf(\"/negotiate?\") > 0)) {\n      // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\n      allowRetry = false;\n      this._accessToken = await this._accessTokenFactory();\n    }\n\n    this._setAuthorizationHeader(request);\n\n    const response = await this._innerClient.send(request);\n\n    if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\n      this._accessToken = await this._accessTokenFactory();\n\n      this._setAuthorizationHeader(request);\n\n      return await this._innerClient.send(request);\n    }\n\n    return response;\n  }\n\n  _setAuthorizationHeader(request) {\n    if (!request.headers) {\n      request.headers = {};\n    }\n\n    if (this._accessToken) {\n      request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`;\n    } // don't remove the header if there isn't an access token factory, the user manually added the header in this case\n    else if (this._accessTokenFactory) {\n      if (request.headers[HeaderNames.Authorization]) {\n        delete request.headers[HeaderNames.Authorization];\n      }\n    }\n  }\n\n  getCookieString(url) {\n    return this._innerClient.getCookieString(url);\n  }\n\n}","map":{"version":3,"mappings":"AAAA;AACA;AAEA,SAASA,WAAT,QAA4B,eAA5B;AACA,SAASC,UAAT,QAAsD,cAAtD;AAEA;;AACA,OAAM,MAAOC,qBAAP,SAAqCD,UAArC,CAA+C;EAKjDE,YAAYC,WAAZ,EAAqCC,kBAArC,EAAqG;IACjG;IAEA,KAAKC,YAAL,GAAoBF,WAApB;IACA,KAAKG,mBAAL,GAA2BF,kBAA3B;EACH;;EAEgB,MAAJG,IAAI,CAACC,OAAD,EAAqB;IAClC,IAAIC,UAAU,GAAG,IAAjB;;IACA,IAAI,KAAKH,mBAAL,KAA6B,CAAC,KAAKI,YAAN,IAAuBF,OAAO,CAACG,GAAR,IAAeH,OAAO,CAACG,GAAR,CAAYC,OAAZ,CAAoB,aAApB,IAAqC,CAAxG,CAAJ,EAAiH;MAC7G;MACAH,UAAU,GAAG,KAAb;MACA,KAAKC,YAAL,GAAoB,MAAM,KAAKJ,mBAAL,EAA1B;IACH;;IACD,KAAKO,uBAAL,CAA6BL,OAA7B;;IACA,MAAMM,QAAQ,GAAG,MAAM,KAAKT,YAAL,CAAkBE,IAAlB,CAAuBC,OAAvB,CAAvB;;IAEA,IAAIC,UAAU,IAAIK,QAAQ,CAACC,UAAT,KAAwB,GAAtC,IAA6C,KAAKT,mBAAtD,EAA2E;MACvE,KAAKI,YAAL,GAAoB,MAAM,KAAKJ,mBAAL,EAA1B;;MACA,KAAKO,uBAAL,CAA6BL,OAA7B;;MACA,OAAO,MAAM,KAAKH,YAAL,CAAkBE,IAAlB,CAAuBC,OAAvB,CAAb;IACH;;IACD,OAAOM,QAAP;EACH;;EAEOD,uBAAuB,CAACL,OAAD,EAAqB;IAChD,IAAI,CAACA,OAAO,CAACQ,OAAb,EAAsB;MAClBR,OAAO,CAACQ,OAAR,GAAkB,EAAlB;IACH;;IACD,IAAI,KAAKN,YAAT,EAAuB;MACnBF,OAAO,CAACQ,OAAR,CAAgBjB,WAAW,CAACkB,aAA5B,IAA6C,UAAU,KAAKP,YAAY,EAAxE;IACH,CAFD,CAGA;IAHA,KAIK,IAAI,KAAKJ,mBAAT,EAA8B;MAC/B,IAAIE,OAAO,CAACQ,OAAR,CAAgBjB,WAAW,CAACkB,aAA5B,CAAJ,EAAgD;QAC5C,OAAOT,OAAO,CAACQ,OAAR,CAAgBjB,WAAW,CAACkB,aAA5B,CAAP;MACH;IACJ;EACJ;;EAEMC,eAAe,CAACP,GAAD,EAAY;IAC9B,OAAO,KAAKN,YAAL,CAAkBa,eAAlB,CAAkCP,GAAlC,CAAP;EACH;;AA/CgD","names":["HeaderNames","HttpClient","AccessTokenHttpClient","constructor","innerClient","accessTokenFactory","_innerClient","_accessTokenFactory","send","request","allowRetry","_accessToken","url","indexOf","_setAuthorizationHeader","response","statusCode","headers","Authorization","getCookieString"],"sources":["H:\\Projects\\OnlineMarketplace\\OnlineMarketplace\\OnlineMarketplace\\ClientApp\\node_modules\\@microsoft\\signalr\\src\\AccessTokenHttpClient.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\n\r\n/** @private */\r\nexport class AccessTokenHttpClient extends HttpClient {\r\n    private _innerClient: HttpClient;\r\n    _accessToken: string | undefined;\r\n    _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n\r\n    constructor(innerClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined) {\r\n        super();\r\n\r\n        this._innerClient = innerClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n    }\r\n\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        let allowRetry = true;\r\n        if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\r\n            // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\r\n            allowRetry = false;\r\n            this._accessToken = await this._accessTokenFactory();\r\n        }\r\n        this._setAuthorizationHeader(request);\r\n        const response = await this._innerClient.send(request);\r\n\r\n        if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\r\n            this._accessToken = await this._accessTokenFactory();\r\n            this._setAuthorizationHeader(request);\r\n            return await this._innerClient.send(request);\r\n        }\r\n        return response;\r\n    }\r\n\r\n    private _setAuthorizationHeader(request: HttpRequest) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (this._accessToken) {\r\n            request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`\r\n        }\r\n        // don't remove the header if there isn't an access token factory, the user manually added the header in this case\r\n        else if (this._accessTokenFactory) {\r\n            if (request.headers[HeaderNames.Authorization]) {\r\n                delete request.headers[HeaderNames.Authorization];\r\n            }\r\n        }\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        return this._innerClient.getCookieString(url);\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}